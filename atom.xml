<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>超哥的小院</title>
  <icon>https://www.gravatar.com/avatar/488f05073406b1a068962cde7ab389c4</icon>
  <subtitle>超哥的小院</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xigema.run/"/>
  <updated>2020-05-20T16:05:17.305Z</updated>
  <id>https://xigema.run/</id>
  
  <author>
    <name>李文超</name>
    <email>lwch748@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Golang机器学习入门（一）</title>
    <link href="https://xigema.run/2020/05/18/Golang%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://xigema.run/2020/05/18/Golang%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-05-18T16:49:45.000Z</published>
    <updated>2020-05-20T16:05:17.305Z</updated>
    
    <content type="html"><![CDATA[<p>本章将会讲解golang中如何读取样本文件。</p><a id="more"></a><h2 id="样本文件"><a href="#样本文件" class="headerlink" title="样本文件"></a>样本文件</h2><p>首先让我们来看一下什么是样本文件，以下数据摘自<a href="https://www.kaggle.com/justinas/housing-in-london" target="_blank" rel="noopener">kaggle伦敦房屋数据</a></p><pre><code>date,area,average_price,code,houses_sold,no_of_crimes,borough_flag1995-01-01,city of london,91449,E09000001,17,,11995-02-01,city of london,82203,E09000001,7,,11995-03-01,city of london,79121,E09000001,14,,11995-04-01,city of london,77101,E09000001,7,,11995-05-01,city of london,84409,E09000001,10,,11995-06-01,city of london,94901,E09000001,17,,11995-07-01,city of london,110128,E09000001,13,,11995-08-01,city of london,112329,E09000001,14,,11995-09-01,city of london,104473,E09000001,17,,1</code></pre><p>从以上内容可见，样本文件是一个多行的文件，每一行为一个样本，每一列表示该样本的一个属性（特征）。</p><h2 id="特征解释"><a href="#特征解释" class="headerlink" title="特征解释"></a>特征解释</h2><ol><li><code>date</code>: 该字段表示采样日期</li><li><code>area</code>: 该字段表示样本所属地区</li><li><code>average_price</code>: 该字段表示房屋均价</li><li><code>code</code>: 该字段表示所属地区的邮政编码</li><li><code>houses_sold</code>: 该字段表示所属地区出售房屋数量</li><li><code>no_of_crimes</code>: 该字段表示所属地区的犯罪案件数量</li><li><code>borough_flag</code>: 该字段表示所属区域是否是一个自治区</li></ol><p>通过进一步观察发现，<code>date</code>字段为日期类型，<code>area</code>和<code>code</code>字段为字符串类型，其他所有字段均为数值类型。</p><h2 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h2><p>下面让我们来考虑一下如何进行建模（创建数据结构），首先根据第一行内容我们可以得到一些column（字段）</p><pre><code>type columnType int const (    columnTime columnType = iota    columnString    columnInt    columnFloat)// Column data columntype Column struct {    index      int     name       string    t          columnType    timeParse  func(string) time.Time    timeFormat func(time.Time) string}</code></pre><p>根据上面的类型定义，我们需要支持<code>string</code>、<code>int</code>、<code>float</code>和<code>time</code>四种类型的字段（引入float类型仅为了方便运算）。类型中的<code>index</code>和<code>name</code>是为了定位到字段的位置与名称的，<code>timeParse</code>函数和<code>timeFormat</code>函数用于对日期时间类型的字段进行序列化与反序列化。</p><p>下面我们需要定义一种数据结构来保存每一个维度的特征（表示为一个单元格）</p><pre><code>// Cell data celltype Cell struct {    t          columnType    s          string    i          int    f          float64    ts         time.Time    timeFormat func(time.Time) string    empty      bool}</code></pre><p>该类型支持<code>string</code>、<code>int</code>、<code>float</code>和<code>time</code>这四种类型的数据，当<code>empty</code>字段为true时表示当前单元格的内容为空。对于空单元格需要进行内容的填充，将会在下个章节中进行介绍。</p><p>最后我们定义一种结构来保存所有单元格的数据，为了方便数据读取我们通过两种方式来保存数据：</p><ul><li><p>通过index来找到对应的column或cell</p></li><li><p>通过name来找到对应的column或cell</p><pre><code>// Data datatype Data struct {    columnsByIndex map[int]*Column    columnsByName  map[string]*Column    cellsByIndex []map[int]*Cell    cellsByName  []map[string]*Cell    loaded bool}</code></pre></li></ul><h2 id="载入数据"><a href="#载入数据" class="headerlink" title="载入数据"></a>载入数据</h2><p>现在我们已经有了所有的数据结构，下面让我们来看一下如何加载样本文件</p><pre><code>// AddColumn add column definitionfunc (d *Data) AddColumn(col Column) *Column {    d.columnsByIndex[col.index] = &amp;col    d.columnsByName[col.name] = &amp;col    return &amp;col}// LoadFromCSV read data from csvfunc (d *Data) LoadFromCSV(r io.Reader, skipHeader bool) error {    if len(d.columnsByIndex) == 0 {        return constant.ErrNoColumns    }    cr := csv.NewReader(r)    var rowIndex int    for {        row, err := cr.Read()        if err != nil {            if err == io.EOF {                d.loaded = true                return nil            }            return err        }        rowIndex++        if rowIndex == 1 &amp;&amp; skipHeader {            continue        }        d.addRow(row)    }}func (d *Data) addRow(row []string) {    index := make(map[int]*Cell)    name := make(map[string]*Cell)    for idx, col := range d.columnsByIndex {        str := row[idx]        var cell Cell        cell.t = col.t        if len(str) == 0 {            cell.empty = true        } else {            switch col.t {            case columnString:                cell.s = str            case columnInt:                n, _ := strconv.ParseInt(str, 10, 64)                cell.i = int(n)            case columnFloat:                n, _ := strconv.ParseFloat(str, 10)                cell.f = n            case columnTime:                cell.ts = col.timeParse(str)                cell.timeFormat = col.timeFormat            }        }        index[col.index] = &amp;cell        name[col.name] = &amp;cell    }    d.cellsByIndex = append(d.cellsByIndex, index)    d.cellsByName = append(d.cellsByName, name)}</code></pre><p>AddColumn函数用于添加字段定义，LoadFromCSV函数则总一个reader中读取csv文件内容，其中skipHeader参数用于表示是否跳过第一行的表头。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>以上内容的代码可从 <a href="https://github.com/lwch/ml/tree/master/data" target="_blank" rel="noopener">https://github.com/lwch/ml/tree/master/data</a> 得到。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章将会讲解golang中如何读取样本文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://xigema.run/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="样本特征" scheme="https://xigema.run/tags/%E6%A0%B7%E6%9C%AC%E7%89%B9%E5%BE%81/"/>
    
  </entry>
  
</feed>
